<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Android WebView 开发使用笔记 | jwcqc个人笔记</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android WebView 开发使用笔记</h1><a id="logo" href="/.">jwcqc个人笔记</a><p class="description">年华虚度 空有一身疲惫</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android WebView 开发使用笔记</h1><div class="post-meta">Jul 21, 2016<span> | </span><span class="category"><a href="/categories/Android/">Android</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>最近在做的一个项目，涉及到关于WebView的监控，因此花了些时间查阅资料，并通过在页面加载完成后插入JS代码成功监控到了所需的信息，目前功能已全部完成，因此打算写下来做个总结，这一篇先记录一下对WebView的基本使用以及注意事项，下一篇详细讲述一下对WebView监控的实现。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>主要就是开启Javascript支持，设置WebViewClient和WebChromeClient等操作，下面代码中都有注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">webview = (WebView) findViewById(R.id.webview);</div><div class="line">WebSettings setting = webview.getSettings();</div><div class="line">setting.setJavaScriptEnabled(true);// 如果访问的页面中有JavaScript，或者需要通过js和页面交互，则必须设置支持Javascript</div><div class="line">webview.setWebViewClient(new WebViewClient() &#123;</div><div class="line">	@Override</div><div class="line">	public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">		// 重写这个方法用来指定url，比如只有特定的url才在webview里打开，否则还是启动浏览器去打开，返回true或者false</div><div class="line">	    return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	// 如果要显示进度条，可以通过onPageStarted和onPageFinished这两个方法实现，在onPageFinished结束即可</div><div class="line">    @Override</div><div class="line">    public void onPageStarted(WebView view, String url, Bitmap favicon) &#123;</div><div class="line">	    super.onPageStarted(view, url, favicon);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onPageFinished(WebView view, String url) &#123;</div><div class="line">	    super.onPageFinished(view, url);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">webview.setWebChromeClient(new WebChromeClient() &#123;</div><div class="line"></div><div class="line">	// 可以通过拦截JS中的如下3个提示方法，也就是几种样式的对话框（在JS中有三个常用的对话框方法alert、comfirm、prompt），</div><div class="line">	// 得到他们的消息内容，然后解析即可。这样可达到修改弹出框样式与app风格统一，或者与本地代码进行交互的目的，</div><div class="line">	 @Override</div><div class="line">	 public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">	     return super.onJsAlert(view, url, message, result);</div><div class="line">	 &#125;</div><div class="line"></div><div class="line">     @Override</div><div class="line">     public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">	     return super.onJsConfirm(view, url, message, result);</div><div class="line">     &#125;</div><div class="line">     </div><div class="line">	 @Override</div><div class="line">     public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</div><div class="line">	     return super.onJsPrompt(view, url, message, defaultValue, result);</div><div class="line"></div><div class="line">     @Override</div><div class="line">     public void onReceivedTitle(WebView view, String title) &#123;</div><div class="line">	     super.onReceivedTitle(view, title);</div><div class="line">     &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//webView.loadUrl(file:///android_asset/test.html);//如果是加载本地文件则用这种写法</div><div class="line">webview.loadUrl(url); //最后调用loadUrl加载网页</div></pre></td></tr></table></figure></p>
<p>最后别忘了在AndroidManifest.xml中添加网络权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="拦截请求"><a href="#拦截请求" class="headerlink" title="拦截请求"></a>拦截请求</h2><p>WebView 调用 loadUrl 后，会首先根据URL获取响应，然后再将响应显示到页面上，但我们可以在获取响应过程中重新改变请求URL或者直接将响应替换掉，具体的替换可以在 WebViewClient 中shouldInterceptRequest(WebView view, WebResourceRequest request)方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public WebResourceResponse shouldInterceptRequest(WebView view, WebResourceRequest request) &#123;</div><div class="line">	String response = &quot;&lt;html&gt;&lt;title&gt;测试拦截&lt;/title&gt;&lt;body&gt;替换成了我自己的内容&lt;/body&gt;&lt;/html&gt;&quot;;</div><div class="line">	WebResourceResponse webResourceResponse = </div><div class="line">		new WebResourceResponse(&quot;text/html&quot;, &quot;utf-8&quot;, new ByteArrayInputStream(response.getBytes()));</div><div class="line">	return webResourceResponse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里需要注意几点：</p>
<ol>
<li>另外还有一个同名不同参方法shouldInterceptRequest (WebView view, String url) ，但是在 API 21已经过时了，因此这里没有去覆盖了；</li>
<li>shouldInterceptRequest 方法是在非UI线程中，因此当需要与 View 交互要小心。但是一想，既然是在非UI线程中，那么我们其实也可以在其中做网络请求，比如获取 <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a> 的响应数据，将请求的百度替换为 google等；</li>
<li>通过拦截请求，也可以做到在网页内容中删除某些内容以使在手机上显示好看，只需将响应中的部分内容删除之后再交由WebView去显示即可，这个就跟具体的业务相关了。</li>
</ol>
<h2 id="JS代码与本地代码交互"><a href="#JS代码与本地代码交互" class="headerlink" title="JS代码与本地代码交互"></a>JS代码与本地代码交互</h2><p>在平时与WebVew打交道的过程中，其实我们或多或少都用过如下三种方式或之一来实现WebView中JS与本地代码的交互：</p>
<ol>
<li><p>利用WebViewClient接口回调方法拦截url<br>这种方式就是为WebVew添加 WebViewClient 回调接口，在 shouldOverrideUrlLoading 回调方法中拦截url，然后解析这个url的协议，如果发现是我们约定好的协议就开始解析参数执行具体逻辑；</p>
</li>
<li><p>利用WebChromeClient回调接口的三个方法拦截消息<br>前面基本使用真的代码中也已经注释过了，为WebVew添加 添加 WebChromeClient 接口后，可以拦截JS中的几个提示方法，也就是几种样式的对话框，在JS中有三个常用的对话框方法：</p>
<ul>
<li>alert 是弹出警告框，在文本里面加入\n就可以换行。</li>
<li>confirm 弹出确认框，会返回布尔值，通过这个值可以判断点击时确认还是取消。true表示点击了确认，false表示点击了取消。</li>
<li>prompt 弹出输入框，点击确认返回输入框中的值，点击取消返回null。<br>这三种对话框都是可以在本地拦截到的，那么这种方法的原理就是拦截这些方法，得到他们的消息内容，然后解析即可；</li>
</ul>
</li>
<li><p>通过addJavascriptInterface方法进行添加对象映射<br>addJavascriptInterface方法需要两个参数，第一个参数：Android本地对象；第二个参数：JS代码中需要使用的对象。所以这里其实就相当于一个映射关系，把Android中的本地对象和JS中的对象关联即可，然后就可以通过JS对象.方法名调用到这个Android本地对象中的方法。</p>
</li>
</ol>
<p>Android4.2 之后，为了修复之前的安全漏洞，需要为Android本地对象中的方法加上注解约束@JavascriptInterface，只有加上这个注解的方法才会被JS调用到。关于漏洞的严重性以及解决的一些办法，可以参考这篇文章 <a href="http://blog.csdn.net/leehong2005/article/details/11808557" target="_blank" rel="external">http://blog.csdn.net/leehong2005/article/details/11808557</a></p>
<p>注意如果代码进行了混淆，则需要在proguard.cfg文件中添加对JSObject 的处理，这里不再展开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class JSObject &#123;</div><div class="line">    @JavascriptInterface</div><div class="line">    public void getMsg(String msg) &#123;</div><div class="line">        //handleMsg(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webview.addJavascriptInterface(new JSObject(), &quot;myObj&quot;);</div></pre></td></tr></table></figure>
<p>然后就可以在JS代码中通过myObj.getMsg(“this is a msg”)调用到JSObject中的getMsg方法了。</p>
<p>另外，如果是要在Android代码中调用JS方法或者注入JS代码，则可以通过loadUrl这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">webView.loadUrl(&quot;javascript:jsMethod()&quot;);</div><div class="line">webview.loadUrl(&quot;javascript:xxx&quot;)</div></pre></td></tr></table></figure>
<p>但是，当需要注入一整个JS文件的时候，就要通过在WebViewClient的onPageFinished方法中去想办法了，可以有两种办法</p>
<ol>
<li>当webview加载完之后，读取整个js文件中的内容，然后将整个文件内容以字符串的形式，通过webview.loadUrl(“javascript:fileContentString”)注入，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">URL url = new URL(&quot;js文件的网络地址&quot;);</div><div class="line">in = url.openStream();</div><div class="line">byte buff[] = new byte[1024];</div><div class="line">ByteArrayOutputStream fromFile = new ByteArrayOutputStream();</div><div class="line">FileOutputStream out = null;</div><div class="line">do &#123;</div><div class="line">	int numread = in.read(buff);</div><div class="line">    if (numread &lt;= 0) &#123;</div><div class="line">	    break;</div><div class="line">    &#125;</div><div class="line">    fromFile.write(buff, 0, numread);</div><div class="line">&#125; while (true);</div><div class="line">String wholeJS = fromFile.toString();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onPageFinished(WebView view, String url) &#123;</div><div class="line">	super.onPageFinished(view, url);</div><div class="line">	webview.loadUrl(&quot;javascript:&quot; + wholeJS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>页面加载完之后，直接向webview对应的html中加入script便签，并包含要注入的JS的url地址，代码如下所示。当注入完JS之后想要立即调用其中的方法，可以为加入的script标签添加onload事件，确保该script已加载完成之后，在onload方法里调用JS文件中的方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String js = &quot;var script = document.createElement(&apos;script&apos;);&quot; +</div><div class="line">                &quot;    script.src = &apos;http://locahost:8080/xxx/xxx.js&apos;;&quot; +</div><div class="line">                &quot;    script.onload = function() &#123; xxx(); &#125;;&quot;  + </div><div class="line">                &quot;    document.body.appendChild(script);&quot;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onPageFinished(WebView view, String url) &#123;</div><div class="line">	super.onPageFinished(view, url);</div><div class="line">	webview.loadUrl(&quot;javascript:&quot; + js);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="WebView缓存"><a href="#WebView缓存" class="headerlink" title="WebView缓存"></a>WebView缓存</h2><p>WebView的缓存可以分为页面缓存和数据缓存。 </p>
<ol>
<li><p>页面缓存是指加载一个网页时的html、JS、CSS等页面或者资源数据，这些缓存资源是由于浏览器的行为而产生，开发者只能通过配置HTTP响应头影响浏览器的行为才能间接地影响到这些缓存数据。他们的索引存放在/data/data/package_name/databases下。他们的文件存放在/data/data/package_name/cache/xxxwebviewcachexxx下。文件夹的名字在2.x和4.x上有所不同，但都文件夹名字中都包含webviewcache；</p>
</li>
<li><p>数据缓存分为两种：AppCache和DOM Storage（Web Storage）。他们是因为页面开发者的直接行为而产生。所有的缓存数据都由开发者直接完全地掌控。</p>
</li>
</ol>
<p>AppCache使我们能够有选择的缓存web浏览器中所有的东西，从页面、图片到脚本、css等等。尤其在涉及到应用于网站的多个页面上的css和JavaScript文件的时候非常有用。其大小目前通常是5M，在WebView上需要手动开启（setAppCacheEnabled），并设置路径（setAppCachePath）和容量（setAppCacheMaxSize）</p>
<p> 如果需要存储一些简单的用key/value对即可解决的数据，DOM Storage是非常完美的方案。根据作用范围的不同，有Session Storage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）。在WebView中可以手动开启DOM Storage（setDomStorageEnabled）并设置存储路径（setDatabasePath）</p>
<p>假设activity中已经有了一个WebView的实例对象，可以参考如下代码最WebSettings 进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">WebSettings webseting = webview.getSettings();  </div><div class="line">setting.setJavaScriptEnabled(true);</div><div class="line">webseting.setDomStorageEnabled(true);             </div><div class="line">webseting.setAppCacheMaxSize(1024*1024*8); //设置缓冲大小，这里设的是8M  </div><div class="line">String appCacheDir = getApplicationContext().getCacheDir().getAbsolutePath();</div><div class="line">webseting.setAppCachePath(appCacheDir);  </div><div class="line">webseting.setAllowFileAccess(true);  </div><div class="line">webseting.setAppCacheEnabled(true);  </div><div class="line">webseting.setCacheMode(WebSettings.LOAD_DEFAULT);</div></pre></td></tr></table></figure></p>
<h2 id="处理WebView中页面需要的其他权限"><a href="#处理WebView中页面需要的其他权限" class="headerlink" title="处理WebView中页面需要的其他权限"></a>处理WebView中页面需要的其他权限</h2><p>比如从安卓5.0起WebView开始支持WebRTC，如果用WebView加载一个通过WebRTC进行音视频通讯的页面，我们会发现即使Manifest当中请求了摄像头和麦克风权限，并且系统中也已授予，但还是无法调用到，页面无法显示内容，这时候我们其实还需要重写WebChromeClient中的一个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void onPermissionRequest(PermissionRequest request) &#123;</div><div class="line">	request.grant(request.getResources());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>由于服务器各种原因导致出错，最平常的比如404错误，通常情况下浏览器会显示一个错误提示页面，用来提示用户页面出错了，但这个页面一般比较简陋，也有可能与我们的页面风格不搭， 这个时候我们就需要为WebView加载一个本地的错误提示页面。</p>
<ol>
<li><p>首先需要编写一个html文件，比如error.html，用来出错的时候展示给用户，然后将该文件放置到代码根目录的assets文件夹下；</p>
</li>
<li><p>随后我们需要复写WebViewClient的onRecievedError方法，该方法传回了错误码，根据错误类型可以进行不同的错误分类处理。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">webview.setWebViewClient(new WebViewClient()&#123;</div><div class="line">	@Override</div><div class="line">    public void onReceivedError(WebView view, int errorCode,</div><div class="line">	    String description, String failingUrl) &#123;</div><div class="line">	    switch(errorCode) &#123;</div><div class="line">		    case HttpStatus.SC_NOT_FOUND:</div><div class="line">		        view.loadUrl(&quot;file:///android_assets/error.html&quot;);</div><div class="line">		        break;</div><div class="line">	    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然，出错的时候也可以选择隐藏掉webview，而显示native的错误处理控件，这个也只需要在onReceivedError进行相应的处理即可。</p>
<h2 id="处理返回键监听"><a href="#处理返回键监听" class="headerlink" title="处理返回键监听"></a>处理返回键监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</div><div class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) &#123;</div><div class="line">        webView.goBack();</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return super.onKeyDown(keyCode, event);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考链接：</p>
<p><a href="http://blog.csdn.net/jiangwei0910410003/article/details/52687530" target="_blank" rel="external">http://blog.csdn.net/jiangwei0910410003/article/details/52687530</a><br><a href="http://www.cnblogs.com/rayray/p/3680500.html" target="_blank" rel="external">http://www.cnblogs.com/rayray/p/3680500.html</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://jwcqc.me/2016/07/21/android-webview-development-notes/" data-id="cj06hhlyb00014sv8bqf2pqap" class="article-share-link">分享到</a><div class="tags"><a href="/tags/WebView/">WebView</a></div><div class="post-nav"><a href="/2016/07/31/android-webview-performance-monitor/" class="pre">Android WebView 页面性能监控实现</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://jwcqc.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/WebView/" style="font-size: 15px;">WebView</a> <a href="/tags/WebRTC/" style="font-size: 15px;">WebRTC</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/03/wxpay-develop-process/">微信支付后台开发步骤</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/01/25/mongo-authentication/">MongoDB启用认证权限-记一次公网数据库被删经历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/06/jvm-runtime-memory-structure/">Java虚拟机运行时内存结构</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/24/jvm-performance-monitor-and-tools/">JVM性能监控与故障处理工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/11/04/naive-bayes/">机器学习经典算法-朴素贝叶斯(Naive Bayes)及其应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/11/mqtt-redis-achieve-single-account-login/">使用MQTT协议+Redis缓存实现APP登录顶号功能</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/26/apprtc-server-build-process/">AppRTC服务器搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/18/vmware-network-configuration/">VMWare虚拟机网络配置</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/31/android-webview-performance-monitor/">Android WebView 页面性能监控实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/21/android-webview-development-notes/">Android WebView 开发使用笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://i-test.com.cn/" title="用户行为分析平台" target="_blank">用户行为分析平台</a><ul></ul><a href="https://i-test.com.cn/" title="WebRTC使用" target="_blank">WebRTC使用</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">jwcqc个人笔记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>